\documentclass[Main]{subfiles}

\begin{document}

\section{Meggitt decoder}
The Meggitt decoder is able to decode an input message, $r(X)$, which may contain 1 or 2 error and return the correct output vector, $v(X)$.
If $r(X)$ contains 3 error it the decoder should be able to detect error but not able to correct it.

When calling the meggitt decoder is start with calculate the error pattern as in (HENVISNING meggitt decoder slutning, tabel) and finding the corresponding syndromes.
In Matlab this is done with the function in \codeTitle \ref{lst:ErrorPatternCreate}

\begin{lstlisting}[caption=Error pattern creation, style=Code-Matlab, label=lst:ErrorPatternCreate]
 function syndromes_errorpattern = generateErrorPattern(g,n,k)
 % generate syndrome error pattern
 
 errorpattern = fliplr(eye(n));
 errorpattern(:,n) = 1;
 syndromes_errorpattern = zeros(n,n-k);
 
 for i = 1:n
     [q, s] = gfdeconv(errorpattern(i,:), g, 2);
     if(length(s) ~= n-k)
         syndromes_errorpattern(i,:) = [s zeros(1,n-k-length(s))];
     else
         syndromes_errorpattern(i,:) = s;
     end
 end
\end{lstlisting}

The initiation of the syndrome register is happening next.
As it was shown in (HENVISNING TIL AFSNIT MEGGITT DECODER) the initialization of the syndrome register is the same at making a polynomial division of $S(X)$ and $g(X)$.
With this knowledge the function in MatLab is as shown in \codeTitle \ref{lst:SyndromeInit}.
If the syndrome vector is less than k, when it don't have any bit in the high end, the syndrome is filled up with zero so they all have a length of k.

\begin{lstlisting}[caption=Syndrome initialization, style=Code-Matlab, label=lst:SyndromeInit]
 function iSyndrome = init_Syndrome(r,g,n,k)
 % function iSyndrome = init_Syndrome(r,g,n,k)
 
 [q, iSyndrome] = gfdeconv(r,g,2);
 
 if(length(iSyndrome) ~= n-k)
     iSyndrome = [iSyndrome zeros(1,n-k-length(iSyndrome))];
 end
\end{lstlisting}



\begin{lstlisting}[caption=Error detection, style=Code-Matlab, label=lst:ErrorDetection]
 for i = 1:n
     % Test of syndrome is equal to one of the error syndromes
     for b = 1:n
         % Check if the calculated syndrome is equal to one of the rows in syndrome
         % table
         if(isequal(si, syndromes_errorpattern(b,:))==1)
             % correct bit, if error happened
             error_vec(i) = 1;
             r(end) = mod(r(end)+1,2);
         end
     end
     
     % Right shift the received vector 1 bit
     ri = circshift(r, [1 1]);
     % Calculate new syndrome register
     [q, si] = gfdeconv(ri,g,2);
     % Set r to ri (make the shift in memory too)
     r = ri;
     % zeropad si to compare with the syndrome table
     if(length(si) ~= n-k)
         si = [si zeros(1,n-k-length(si))];
     end
 end
\end{lstlisting}


.\newline
.\newline
The Meggitt decoder can decode an input message, $r(X)$, which may contain up to 2 errors and return the correct output vector, $v(X)$.
The Meggitt decoder can be called in Matlab with the function in \codeTitle \ref{lst:Meggitt}

\begin{lstlisting}[caption=Meggit decoder function, style=Code-Matlab, label=lst:Meggitt]
function res = Meggitt(r)

	syndrome = InitSyndrome(r);
	buffer = r;
	L = length(r(1,:));
	
	error = zeros(1, L);
	
	for i = 1:L
	   [error(1,i), syndrome] = Detector(0, syndrome); 
	
	   output = mod(buffer(1,L) + error(1,i),2);
	
	   buffer = circshift(buffer,[-1 1]);
	   buffer(1,1) = output;   
	end
	
	res = buffer;
end
\end{lstlisting}
First the decoder will call analyze the input vector to return the syndrome value for input vector.
Then it will store the input vector in a buffer and calculate the length of the vector.

After initializing an empty error vector (same size as the input vector) it will for every symbol in the input vector do the following:
\begin{itemize}

\item Calculate the new syndrome and whether there's an error (explained in \codeTitle \ref{lst:Detector}). Notice the first input is zero (explained in the next paragraph).

\item Calculate the bit value modulo 2 of the buffer and the calculated error.

\item Shift all bits in the buffer and overwrite the first bit in the buffer with the new value.
\end{itemize}
After this the buffer is returned as the result.
\\
\\
The detector will return the syndrome vector for input vector and whether any errors has been detected.
The function is shown in \codeTitle \ref{lst:Detector}.
The input is a new bit from the input vector (0 if all bits have been listed) to be analyzed and the current syndrome vector.
\\
\\
First the syndrome bits will be run through an AND-gate with the second parameter inverted.
A '1' will indicate an error.
\\
Then the bits in the syndrome is shifted one place to the right and the the last bit is stored.
The new value for this bit is calculated by adding the error, the last syndrome bit and the input vector bit in modulo 2.
This value is stored as the new value for the last bit in the syndrome vector.
\\
Then the second syndrome vector bit is calculated with stored syndrome value and the current value in modulo 2.
\\
The new syndrome is then returned with error value.

\begin{lstlisting}[caption=Detector function, style=Code-Matlab, label=lst:Detector]
function [error, syndromeOut] = Detector(r, syndromeIn)
%r = r(x) bit
%syndromeIn

    %Detect error
    error = TriAnd(syndromeIn(1,1), syndromeIn(1,2), syndromeIn(1,3));

    %Shift currentinput and syndrome 1 rot he right
    syndrome = circshift(syndromeIn,[-1 1]);

    %Save last syndrome
    lastSyndrome = syndrome(1,1);

    %Modulo 2 on error, last syndrome output and the input vector bit
    newSyndromeValue = mod(error + lastSyndrome + r, 2); 
    
    %Replace first syndrome bit with the calculated syndrom value
    syndrome(1,1) = newSyndromeValue;

    %Modulo 2 on the last syndrom and the second for the new sydrome's 
    %second bit
    syndrome(1,2) = mod(syndrome(1,2) + lastSyndrome, 2);

    %Returnt he calculated syndrome
    syndromeOut = syndrome;
end
\end{lstlisting}
When the Meggitt detector is called the syndrome vector will consist only of zeros and must be shifted in.
By calling the $InitSyndrome(r)$ function (\codeTitle \ref{lst:InitSyndrome}) the syndrome can be found when all bits are shifted in.
\\
First the length of the input vector is found, and the syndrome is reset.
For every bit, from right to left, the bits will be run through the $Detector$ function (\codeTitle \ref{lst:Detector}) to return the new syndrome.
Notice the error value is ignored, since it is not useful for the initialing.


\begin{lstlisting}[caption=InitSyndrome function, style=Code-Matlab, label=lst:InitSyndrome]
function [syndrome] = InitSyndrome(r)
%Initialize the syndrome vector
%Input the vector, r
%Returns the syndrome vector

    L = length(r(1,:));
    syndrome = [0 0 0];
    for i = 1:L
       [~, syndrome] = Detector(r(1,L+1-i), syndrome); 
    end
end
\end{lstlisting}
The $TriAnd$ function takes 3 parameters, inverts the second parameter and AND the values, as shown in \codeTitle \ref{lst:TriAnd}.

\begin{lstlisting}[caption=TriAnd function, style=Code-Matlab, label=lst:TriAnd]
function res = TriAnd(a, b, c)
%And gate with second input inverted
%Only input [1 0 1] will return 1

    if( a == 1 && b == 0 && c == 1)
        res = 1;
    else
        res = 0;
    end
end
\end{lstlisting}


\end{document}