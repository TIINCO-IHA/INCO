\documentclass[Main]{subfiles}

\begin{document}
\section{Case Study}

(PrÃ¦sentation af opgaven)

(Implementering i matlab)

(Kodeeksempler)

(Problemer undervejs --> faldgruber)

\subsection{Case Study}
This case study concerns the implementation of a Meggitt decoder which has been implemented in Matlab. 

\noindent The Meggitt decoder is implemented as a function that can decode cyclic codes based on the Meggitt algorithm. Besides the Meggitt decoder function the Matlab codes consist of two other functions: a cyclic code encoder, and a main function.

\noindent The cyclic code encoder encodes a message vector into systematic code. The main function generates a message vector and then uses the cyclic code encoder to encode the message vector. It then transmits the code vector through an artificial communication channel and hereby introduces errors to the code vector. Finally it uses the Meggitt decoder to decode the received vector. 

\noindent The conditions given for the case study are: 
\begin{itemize} \itemsep0pt \parskip0pt \parsep0pt
\item Code length: 15
\item Message length: 7
\item Generator polynomial: $g(X)=1+X^4+X^6+X^7+X^8$
\end{itemize} 

\noindent All three functions are described in detail in the following. 


\subsection{Implementation of Encoder}
The implemented encoder is a Matlab function, $cyclicEncoder$. The encoder is able to encode a message vector into systematic code by receiving a generator polynomial $g$ and a message vector $m$. In addition the encoder has been made generic so that it also is possible to state the code length $n$ and the message length $k$ - if nothing is stated, the default value of n is 15 and k is 7. The output of the function is a code vector, $c$. 

\noindent Initially the function converts the message polynomial in vector form into a vector of the length n by shifting it $n-k$ to the right and thereby forming the polynomial $X^{n-k}m(X)$. 

\noindent Secondly, the now right-shifted message polynomial is divided by the generator polynomial to find the remainder polynomial, $p(X)$.

\noindent Finally, adding the right-shifted message polynomial and the remainder polynomial results in the code polynomial.  

\begin{lstlisting}[caption=Cyclic Encoder, style=Code-Matlab, label=lst:refID]
% cyclicEncoding is a function that encodes a message vector into systematic code given the following parameters
% g is the generator polynomial in vector form
% m is message vector
% n is the code length
% k is the message length
function c = cyclicEncoding(g,m,n,k)

% Form the polynomial X^(n-k)*m(X) by right-shifting m n-k times 
shifted_m = [zeros(1,n-k) m];

% Find the remainder, p, by dividing shifted_m by g over GF(2) (q is a factor)
[q, p] = gfdeconv(shifted_m,g,2);

% Extend p with zeros to having the length of n (to be able to add p with shifted_m)
p = [p zeros(1, n-length(p))];

% Obtain the code vector c by using binary addition to add shifted_m and p 
c = mod(shifted_m+p,2);
\end{lstlisting}

\subsection{Implementation of Main Function}
The main function generates a message vector, encodes it into a code vector, transmits it and hereby introduces errors in the code vector, and finally decodes the code vector using Meggitt decoding.

\noindent The main function makes use of the generic cyclic encoder and the Meggitt decoder described above. It is possible to decide how many errors, $t$, should be introduced during transmission, as well as it is possible to manually introduce the error location(s).

\noindent Initially the code length, the message length and the generator polynomial are set. A message vector is generated and by the cyclic encoder encoded into a code vector. 

\noindent Secondly, the number of errors to be introduced are stated and random error location(s) are generated. The code vector is put into the received vector and the bits at the error location(s) in the received vector are flipped. 

\noindent Finally, the received vector is decoded by the Meggitt decoder and it is verified that the decoded vector is equal to the code vector.    

\begin{lstlisting}[caption=Main Function, style=Code-Matlab, label=lst:refID]
% This code makes use of the cyclic encoder and the Meggitt decoder 
addpath('../Encoder');
addpath('../Meggitt');

% Set the code length, the message length and the generator polynomial
n = 15;
k = 7;
g = [1 0 0 0 1 0 1 1 1];

% Generate a message vector by using random numbers in GF(2)
m = mod(randi(2,1,k),2);

% Encode the message vector by the cyclic code encoder function
c = cyclicEncoding(g,m,n,k);

% Transmit the code vector through an artificial communication channel, i.e.
% introduce one or two errors to the code vector 

% State the number of errors, t, to introduce in the code vector (t=1 or t=2)
t = 1;
% t = 2;

% Generate random error locations and state them in a sorted array - if there are two errors and they happen to be in the same location then generate two new error locations
errorlocation = sort(randi(n,1,t)); 
while(t == 2 && (errorlocation(1)-errorlocation(2)) == 0)
    errorlocation = sort(randi(n,1,t));
    disp('Errorlocation was recalculated!');
end

% Put the code vector c into the received vector r
r = c;

% Introduce errors at the generated error location(s) i the received vector by adding 1 and modulo 2 for binary addition (flipping the bits)
r(errorlocation) = mod(c(errorlocation)+1,2);

% Decode the received vector by the Meggitt decoder
res = Meggitt(r)

% Verify that the result of the decoding is equal to the code vector
isequal(c, res)
\end{lstlisting}

\end{document}
